<html><head>
<script>
/*
  Copyright 2013 Andrew Lundin
  MIT License
  http://opensource.org/licenses/MIT

  This is only a prototype, throw-away code.
  Don't mind the globals variables, inline constants,
  and other elements of bad style.  ;)
*/

var prev_x = 0;
var prev_y = 0;
var prev_angle = 0;
var filter_delta = 0;
var adaptive_delta = 0;
var prev_distance = 0;
var coasting_timer = 0;
var chunk_pos = 240;

function init() {
    var pad = document.getElementById("pad");
    pad.onmousemove = handleMouseMove;
    handleMouseMove({clientX:0,clientY:0});
}

function handleMouseMove (event) {

    // new event cancels coasting
    if (coasting_timer)
        window.clearInterval(coasting_timer);

    info("CLEAR");
    var dx = event.clientX - prev_x;
    var dy = event.clientY - prev_y;
    info("dx", dx);
    info("dy", dy);

    var angle = Math.atan2(dy, dx);
    var delta = delta_angle(prev_angle, angle);
    var abs_delta = Math.abs(delta);
    var distance = Math.sqrt(dx * dx + dy * dy);

    // clamp spikes
    if (abs_delta > .5)
        delta = .5 * delta / abs_delta;
    info("delta", delta);

    // error estimation
    var delta_error = (delta - filter_delta) * 10;
    delta_error *= delta_error;
    info("delta_error", delta_error);

    // naive filter for error estimation on next event
    filter_delta = (delta + filter_delta) / 2;
    info("filter_delta", filter_delta);

    // reduce weight for small movements
    var min_distance = Math.min(distance, prev_distance) / 10;
    min_distance = Math.log(min_distance + 1);
    info("min_distance", min_distance);

    // calculate adaptive filter coefficient
    var weight = abs_delta * min_distance / (1 + delta_error);
    if (weight > 1)
        weight = 1;
    info("weight", weight);

    // adaptive filter
    if (weight > 0)
        adaptive_delta = delta * weight + adaptive_delta * (1 - weight);

    // cubic response
    var output_delta = adaptive_delta * adaptive_delta * adaptive_delta;
    info("output_delta", output_delta * 100);

    // store history
    prev_x = event.clientX;
    prev_y = event.clientY;
    prev_angle = angle;
    prev_distance = distance;

    // update bar graph and scrolling chunk
    update_bar("raw", delta, true);
    update_bar("filtered", filter_delta, true);
    update_bar("smooth", output_delta, false);
    update_chunk_position(output_delta);

    // begin coasting if no event received after a short delay
    // this would be integrated into the driver's existing coasting system
    coasting_timer = window.setInterval(coast, 30)
}

function coast() {
    var friction = .02;
    if (adaptive_delta > friction)
        adaptive_delta -= friction;
    else if (adaptive_delta < -friction)
        adaptive_delta += friction;
    else {
        window.clearInterval(coasting_timer);
        adaptive_delta = 0;
    }
    coasting_delta = adaptive_delta * adaptive_delta * adaptive_delta;
    info("coasting_delta", coasting_delta * 100);
    update_bar("raw", 0, false);
    update_bar("filtered", 0, false);
    update_bar("smooth", coasting_delta, false);
    update_chunk_position(coasting_delta);
}

function delta_angle(a1, a2) {
    var n = (a2 - a1);
    var d = (2 * Math.PI);
    var da = n - parseInt(n/d) * d;

    if (da < 0)
        da += 2 * Math.PI;
    if (da > Math.PI)
        da -= 2 * Math.PI;
    return da;
}

function update_chunk_position(output_delta) {
    var chunk = document.getElementById("chunk");
    chunk_pos -= output_delta * 500;
    if (chunk_pos < 0) chunk_pos += 480;
    if (chunk_pos > 480) chunk_pos -= 480;
    chunk.style.top = parseInt(chunk_pos) + "px";
}

function update_bar(name, linear_value, cubed) {
    if (cubed == true) linear_value *= linear_value * linear_value;
    display_value = linear_value * 2000;
    var bar = document.getElementById(name);
    bar.style.height = parseInt(Math.abs(display_value)) + "px";
    if (display_value < 0) {
        bar.style.top = 250 + parseInt(display_value) + "px";
        bar.style.backgroundColor = "red";
    } else {
        bar.style.top = 250 + "px";
        bar.style.backgroundColor = "blue";
    }
}

function info(label, value) {
    return;
    var infodiv = document.getElementById("info");
    if (label == "CLEAR") infodiv.innerHTML = "";
    else infodiv.innerHTML += label + ": " + value.toFixed(2) + "<br>";
}

</script>

<style>
    * {
        font-family: sans-serif;
        font-size: 14px;
    }
    
    #pad {
        float: left;
        border: 1px solid black;
        background-color: gray;
        color: darkgray;
        text-align: center;
        font-size: 20px;
        line-height: 100px;
        width: 500px;
        height: 500px;
        margin: auto;
    }

    #outputContainer {
        float: left;
        border: 1px solid black;
        width: 15px;
        height: 500px;
        margin: 0 5px;
    }

    #chunkContainer, #barContainer {
        position: relative;
        float: left;
        border: 1px solid black;
        width: 20px;
        height: 500px;
        margin: 0 5px;
    }
    
    .labelContainer {
        position: absolute;
        bottom: 5px;
        left: 2px;
        -webkit-transform: rotate(-90deg);
        -moz-transform: rotate(-90deg);
        -ms-transform: rotate(-90deg);
        -o-transform: rotate(-90deg);
        transform: rotate(-90deg);
    }
    
    .label {
        position: absolute;
        white-space: pre;
        top: -50%;
    }

    #chunk {
        position: relative;
        width: 20px;
        height: 20px;
        top: 240px;
        color: yellow;
        background-color: green;
        text-align: center;
        line-height: 20px;
    }

    .bar {
        position: relative;
        background-color: red;
        width: 20px;
    }

    #raw {
        opacity: 0.1;
    }

    #filtered {
        opacity: 0.2;
    }

    #smooth {
        opacity: 0.7;
    }

    #info {
        display: none;
        float: left;
        font-family: monospace;
        width : 200px;
        height: 500px;
        overflow: hidden;
    }

</style>

</head>
<body onload="init();">

    <div id="pad">touchpad</div>

    <div id="barContainer"><div class="labelContainer"><div class="label">raw</div></div><div class="bar" id="raw"></div></div>
    <div id="barContainer"><div class="labelContainer"><div class="label">simple filter</div></div><div class="bar" id="filtered"></div></div>
    <div id="barContainer"><div class="labelContainer"><div class="label">adaptive filter</div></div><div class="bar" id="smooth"></div></div>
    <div id="chunkContainer"><div class="labelContainer"><div class="label">scrolling content</div></div><div id="chunk">@</div></div>

    <div id="info"></div>

    <div id="intro">
        <p>This is a prototype of some improvements to the Circular Scrolling
        gesture provided in the X.org synaptics driver.  For a proper 
        introduction, refer to the 
        <a href="http://github.com/galundin/xorg-synaptics-circscroll-improved">README</a>.</p>
        
        <p>Move the cursor around within the "touchpad" region and watch the
        output.  Vary the center, radius, direction, shape, and speed of 
        rotational movement to see how it responds.  It works best 
        with an actual touchpad, because mouse control doesn't provide the 
        same dexterity as a finger.  This prototype does not implement edge 
        detection, and does not respond to button state.</p>
    </div>

</body>
</html>

